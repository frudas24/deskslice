# TODO — Codex Remote Panel (WebRTC + Touch Control + Fullscreen Presetup + Password)

## Objetivo

Remote desktop tuneado (LAN) para operar **la interfaz real del panel Codex dentro de VS Code** desde el celular:

* **Video:** WebRTC (baja latencia)
* **Control:** touch → mouse/keyboard (tap + drag-scroll + typing)
* **Presetup fullscreen:** seleccionar monitor + trazar rectángulos (plugin/chat/scroll)
* **Run cropped:** stream recortado solo al panel Codex
* **Seguridad leve:** UI pide **password** definido en `.env`
* **Sin persistencia:** no se guardan chats ni logs, solo calib y estado mínimo.

---

## 0) Requerimientos

### Funcionales

* [x] Servir una UI web (mobile-first) accesible en LAN: `http://PC:8787`.
* [x] La UI debe pedir password antes de habilitar:

  * WebRTC video
  * WS signaling
  * WS control
* [x] Modo `Presetup (Fullscreen)`:

  * [x] stream de **pantalla completa** del monitor seleccionado
  * [x] UI permite trazar:

    * [x] `plugin_rect` (zona del panel Codex en VS Code)
    * [x] `chat_rect` (área del input)
    * [x] `scroll_rect` (área scrolleable de mensajes)
  * [x] botón `Restart Presetup` para recalibrar y/o cambiar monitor.
* [x] Modo `Run (Cropped)`:

  * [x] stream recortado solo a `plugin_rect`
  * [x] tap/click y drag-scroll afectan Windows en esa zona
  * [x] typing desde `<textarea>` del móvil → host hace click en `chat_rect`, escribe texto, Enter
* [x] UI debe permitir seleccionar monitor en presetup:

  * [x] dropdown “Monitor 1..N”
  * [x] si te equivocas → `Restart Presetup` y cambias monitor.
* [x] `Input Enabled` kill-switch:

  * [x] OFF: sigue video, pero se ignora todo input (mouse/keyboard)

### No funcionales

* [x] MVP: 1 viewer activo (si entra otro, se rechaza o reemplaza: definir e implementar).
* [ ] “No magia”: sin auto-validación; tú calibras manualmente y listo.
* [ ] Windows 11.
* [x] Layout por dominios: `./cmd` cableado, `./internal` lógica.

---

## 1) Estructura del repo (entregable)

* [x] Crear:

```
./cmd/
  codex_remote/
    main.go
    run.go

./internal/
  config/
    config.go
  app/
    app.go
    http_server.go
  session/
    session.go
  calib/
    model.go
    store.go
  monitor/
    model.go
    monitor_windows.go
    monitor_stub.go
  ffmpeg/
    runner.go
    presets.go
    preview.go
    cmd_windows.go
    cmd_other.go
  mjpeg/
    mjpeg.go
  webrtc/
    publisher.go
    rtp_ingest.go
  signaling/
    ws_signaling.go
    protocol.go
  control/
    ws_control.go
    protocol.go
    mapper.go
    gestures.go
    actions.go
  wininput/
    injector.go
    sendinput_windows.go
    mouse.go
    keyboard.go
  web/
    assets.go
    static/
      index.html
      styles.css
      src/
        api.js
        calib.js
        control.js
        main.js
        webrtc.js
  testutil/
    fake_injector.go

./data/
  .env        (runtime)
  calib.json  (runtime)
  .env.sample
```

* [ ] `.gitignore`:

  * [x] `./data/*` (ignorar todo en data)

---

## 2) Dominio: config (`./internal/config`)

### Requerimientos

* [x] Leer `.env` y env vars.
* [x] Password obligatorio.

### Entregables

* [x] `Config`:

```go
type Config struct {
  ListenAddr   string // "0.0.0.0:8787"
  UIPassword   string // env: UI_PASSWORD (required)
  DataDir      string // "./data"
  CalibPath    string // "./data/calib.json"
  FFmpegPath   string // "ffmpeg" o ruta
  FPS          int    // 30
  BitrateKbps  int    // 6000
  MonitorIndex int    // 1
}
```

* [x] `Load() (Config, error)`:

  * [x] si `UI_PASSWORD` vacío → error explícito.

---

## 3) Dominio: session (`./internal/session`)

### Requerimientos

* [x] Estado runtime global:

  * auth
  * inputEnabled
  * mode presetup|run
  * monitorIdx
  * calib
  * punteros/refs a pipeline actual (opcional, pero usualmente se maneja desde app)

### Entregables

* [x] `Session` thread-safe:

  * [x] `Authenticate(pass string) bool`
  * [x] `Logout()`
  * [x] `IsAuthenticated() bool`
  * [x] `SetInputEnabled(bool)`
  * [x] `InputEnabled() bool`
  * [x] `SetMode(mode string)`
  * [x] `Mode() string`
  * [x] `SetMonitor(idx int)`
  * [x] `Monitor() int`
  * [x] `SetCalib(c calib.Calib)`
  * [x] `GetCalib() calib.Calib`
  * [x] `Snapshot()` (para UI / handlers)

---

## 4) Dominio: monitor (`./internal/monitor`)

### Requerimientos

* [x] Enumerar monitores con WinAPI.

### Entregables

* [x] `type Monitor struct { Index int; X,Y,W,H int; Primary bool }`
* [x] `ListMonitors() ([]Monitor, error)`
* [x] `GetMonitorByIndex(list []Monitor, idx int) (Monitor, bool)`
* [x] API: `GET /api/monitors`

---

## 5) Dominio: calib (`./internal/calib`)

### Requerimientos

* [x] Guardar:

  * `PluginAbs` (coords absolutas en monitor)
  * `ChatRel` (coords dentro de plugin)
  * `ScrollRel` (coords dentro de plugin)
  * `MonitorIndex` asociado
* [x] Save/Load JSON.

### Entregables

* [x] Tipos:

```go
type Rect struct{ X, Y, W, H int }
type Calib struct {
  MonitorIndex int
  PluginAbs    Rect
  ChatRel      Rect
  ScrollRel    Rect
}
```

* [x] Helpers:

  * [x] `Normalize(r Rect) Rect`
  * [x] `Contains(r Rect, x, y int) bool`
* [x] `Load(path) (Calib, error)` (si no existe → calib “vacía”)
* [x] `Save(path, c Calib) error`

---

## 6) Dominio: ffmpeg (`./internal/ffmpeg`)

### Requerimientos

* [x] Dos modos:

  * presetup: monitor full
  * run: monitor full + crop a PluginAbs
* [x] Salida a RTP H264 por UDP `127.0.0.1:<port>` (para Pion).
* [x] Restart atómico en cambios: mode/monitor/plugin rect.

### Entregables

* [x] `Runner`:

  * [x] `StartPresetup(m monitor.Monitor, opts) (rtpPort int, stop func() error, err error)`
  * [x] `StartRun(m monitor.Monitor, plugin calib.Rect, opts) (rtpPort int, stop func() error, err error)`
  * [x] `Stop() error`
  * [x] `Restart(...)` (stop anterior + start nuevo)
* [x] `presets.go` con builders:

  * [x] command presetup
  * [x] command run (incluye `crop=w:h:x:y`)
* [x] Captura preferida: `d3d11grab` (fallback `gdigrab` si falla).

---

## 7) Dominio: webrtc (`./internal/webrtc`)

### Requerimientos

* [x] Pion WebRTC, track H264.
* [x] UDP listener RTP local reenvía paquetes a `TrackLocalStaticRTP`.

### Entregables

* [x] `Publisher`:

  * [x] `NewPublisher()`
  * [x] `NewPeer() (*webrtc.PeerConnection, error)`
  * [x] `Track() (*webrtc.TrackLocalStaticRTP, error)`
  * [x] `AttachRTP(port int) error`
  * [x] `StartForwarding()`
  * [x] `StopForwarding()`
  * [x] `ClosePeer()`
* [x] `rtp_ingest.go`:

  * [x] UDP loop read→WriteRTP

---

## 8) Dominio: signaling (`./internal/signaling`)

### Requerimientos

* [x] WebSocket signaling (offer/answer/ice)
* [x] Requiere sesión autenticada
* [x] 1 viewer activo

### Entregables

* [x] WS `/ws/signal`
* [x] Mensajes:

```json
{ "t":"offer", "sdp":"..." }
{ "t":"answer", "sdp":"..." }
{ "t":"ice", "candidate":{...} }
{ "t":"restart" }
```

* [x] `ws_signaling.go`:

  * [x] create/close peerconnection
  * [x] ICE exchange
  * [x] enviar `restart` cuando pipeline reinicia

---

## 9) Dominio: wininput (`./internal/wininput`)

### Requerimientos

* [x] Inyectar mouse/keyboard con WinAPI.
* [x] Debe ser mockeable para unit tests.

### Entregables

* [x] Interfaz `Injector` (`injector.go`):

```go
type Injector interface {
  MoveAbs(x, y int) error
  LeftDown() error
  LeftUp() error
  ClickAt(x, y int) error
  TypeUnicode(text string) error
  Enter() error
  Wheel(delta int) error // opcional
}
```

* [x] Implementación real `WinInjector` (SendInput) en:

  * [x] `sendinput_windows.go`
  * [x] `mouse.go`
  * [x] `keyboard.go`

---

## 10) Dominio: control (`./internal/control`)

### Requerimientos

* [x] WS `/ws/control` (auth requerido)
* [x] Kill-switch respeta inputEnabled
* [x] Mapping coords:

  * presetup: norm → monitor abs
  * run: norm → plugin abs
* [x] Drag-scroll default (si down inicia en scroll_rel)
* [x] Typing:

  * [x] `type{text}` seguido de `enter`:

    * click en chat (centro de ChatRel)
    * type unicode
    * enter

### Entregables

#### 10.1 Protocol (`protocol.go`)

* [x] Mensajes:

```json
{ "t":"down", "id":1, "x":0.5, "y":0.2 }
{ "t":"move", "id":1, "x":0.5, "y":0.25 }
{ "t":"up",   "id":1, "x":0.5, "y":0.25 }
{ "t":"type", "text":"..." }
{ "t":"enter" }

{ "t":"setMode", "mode":"presetup" }
{ "t":"setMode", "mode":"run" }
{ "t":"setMonitor", "idx":2 }
{ "t":"restartPresetup" }

{ "t":"calibRect", "step":"plugin", "rect":{"x":..,"y":..,"w":..,"h":..} }
{ "t":"calibRect", "step":"chat",   "rect":{"x":..,"y":..,"w":..,"h":..} }
{ "t":"calibRect", "step":"scroll", "rect":{"x":..,"y":..,"w":..,"h":..} }

{ "t":"inputEnabled", "enabled":true }
```

#### 10.2 Mapping (`mapper.go`)

* [x] Funciones:

  * [x] `NormToAbsPresetup(xn,yn float64, m monitor.Monitor) (x,y int)`
  * [x] `NormToAbsRun(xn,yn float64, plugin calib.Rect) (x,y int)`
  * [x] clamp de xn/yn a `[0..1]`

#### 10.3 Gestures (lógica pura) (`actions.go`, `gestures.go`)

* [x] Definir acciones:

```go
type ActionType string
const (
  ActMove ActionType = "move"
  ActLeftDown ActionType = "left_down"
  ActLeftUp ActionType = "left_up"
  ActClick ActionType = "click"
  ActType ActionType = "type"
  ActEnter ActionType = "enter"
)
type Action struct { Type ActionType; X,Y int; Text string }
```

* [x] State machine:

  * `down`:

    * en run: calcular frameX/Y dentro del plugin
    * si cae en ScrollRel → iniciar drag (LeftDown)
    * else → click (ClickAt)
  * `move`:

    * solo si drag activo y pointerId coincide
    * throttle 30–60 Hz + ignore micro deltas
  * `up`:

    * si drag activo → LeftUp
* [x] Kill-switch: si inputDisabled → devolver `[]Action{}` en down/move/up/type/enter.

#### 10.4 WS handler (`ws_control.go`)

* [x] Traducir mensajes → `[]Action` → ejecutar via `wininput.Injector`
* [x] En cambios de monitor/mode/calib → notificar a `app` para restart pipeline (callback o channel).

---

## 11) Dominio: app (`./internal/app`)

### Requerimientos

* [x] HTTP + Static UI
* [x] Login endpoint y gating
* [x] Restart pipeline y notify a signaling (`restart`)
* [x] MVP 1 viewer: decidir política:

  * [x] A) rechazar segunda conexión
  * [ ] B) expulsar anterior

### Entregables

#### 11.1 HTTP (`http_server.go`)

* [x] Endpoints:

  * [x] `POST /login` `{password}`

    * 200 OK si match `.env`
    * 401 si no
  * [x] `POST /logout` (opcional)
  * [x] `GET /api/monitors`
  * [x] `GET /api/state` (mode, monitor, inputEnabled, calib present/step completeness)
  * [x] `/` static

#### 11.2 WS routing (`ws_routes.go`)

* [x] `/ws/signal`:

  * cerrar si `!session.IsAuthenticated()`
* [x] `/ws/control`:

  * cerrar si `!session.IsAuthenticated()`

#### 11.3 Pipeline manager (`app.go`)

* [x] `Start()`:

  * [x] enum monitores
  * [x] load calib (si existe)
  * [x] set modo presetup
  * [x] start presetup pipeline
* [x] `RestartPipeline(reason)`:

  * [x] stop ffmpeg
  * [x] stop webrtc forwarding
  * [x] start ffmpeg con:

    * [x] presetup: monitor full
    * [x] run: crop plugin
  * [x] attach RTP port to publisher
  * [x] notify signaling client `{t:"restart"}`

---

## 12) UI (`./internal/web/static`)

### Login

* [x] password input + submit → `/login`
* [x] solo si OK inicializa:

  * signaling WS
  * webrtc negotiation
  * control WS

### Operación

* [x] Video WebRTC
* [x] Top bar:

  * [x] mode selector (Presetup/Run)
  * [x] monitor dropdown
  * [x] Restart presetup
  * [x] InputEnabled toggle
* [x] Calibración:

  * [x] botones: Set Plugin / Set Chat / Set Scroll
  * [x] overlay canvas para trazar rect
  * [x] botón Save (envía `calibRect`)
* [x] Typing:

  * [x] `<textarea>` + botón Send:

    * manda `type{text}` + `enter`
* [x] Gestos:

  * tap: down/up
  * drag: down/move/up (1 dedo) (en run será drag-scroll si comenzó en scroll)

---

# Cableado — `./cmd/codex_remote/main.go` (solo wiring)

* [x] `Load config`
* [x] `List monitors`
* [x] `Load calib`
* [x] Init `Session`
* [x] Init `FFmpeg Runner`
* [x] Init `WebRTC Publisher`
* [x] Init `WinInjector`
* [x] Init `Signaling Server`
* [x] Init `Control Server` (con injector mockable)
* [x] Init `App` (con callbacks para restart)
* [x] Start HTTP server
* [x] Start pipeline presetup
* [x] Graceful shutdown

---

# TODO EXTRA — Unit Tests (anti-regresión)

## Objetivo

Unit tests deterministas para la lógica crítica:

* calib rect ops
* mapping coords
* gestures state machine (drag-scroll)
* kill switch
* session auth
* protocol json decode

### 1) Infra de tests (`./internal/testutil`)

* [x] `fake_injector.go`: implementa `wininput.Injector`, guarda calls en slice:

  * `[]Call{ Name, X,Y, Text }`

### 2) Tests: calib (`./internal/calib`)

* [x] `model_test.go`

  * [x] `TestNormalizeRect_Positive`
  * [x] `TestNormalizeRect_NegativeDims`
  * [x] `TestContains_Inside`
  * [x] `TestContains_Edges` (definir borde inclusive)
  * [x] `TestContains_Outside`
* [x] `store_test.go`

  * [x] `TestSaveLoad_RoundTrip`
  * [x] `TestLoad_MissingFile_ReturnsEmpty` (según diseño)

### 3) Tests: mapper (`./internal/control/mapper_test.go`)

* [x] `TestNormToAbsPresetup_TopLeft`
* [x] `TestNormToAbsPresetup_Center`
* [x] `TestNormToAbsPresetup_BottomRight` (documentar criterio 1.0)
* [x] `TestNormToAbsRun_TopLeft`
* [x] `TestNormToAbsRun_Center`
* [x] `TestNormToAbsRun_BottomRight`
* [x] `TestNormToAbs_ClampOutOfRange`

### 4) Tests: gestures/actions (`./internal/control/gestures_test.go`)

* [x] `TestDragScroll_StartsOnlyInsideScrollRel`
* [x] `TestDragScroll_MoveOnlyWhenActiveAndSamePointer`
* [x] `TestDragScroll_UpStopsAndEmitsLeftUp`
* [x] `TestTapOutsideScroll_EmitsClick`
* [x] `TestInputDisabled_NoActions`
* [x] `TestTypeEnter_EmitsClickTypeEnterSequence` (si lo defines así)

### 5) Tests: session (`./internal/session/session_test.go`)

* [x] `TestAuthenticate_Success`
* [x] `TestAuthenticate_Fail`
* [x] `TestLogout`
* [x] `TestInputEnabled_Toggle`
* [x] `TestSnapshot`

### 6) Tests: protocol JSON

* [x] `./internal/control/protocol_test.go`

  * [x] decode down/move/up/type/enter
* [x] `./internal/signaling/protocol_test.go`

  * [x] decode offer/ice

### 7) Smoke checklist (manual) en README

* [ ] Login OK/FAIL
* [ ] Presetup fullscreen + monitor correcto
* [ ] Calibración plugin/chat/scroll
* [ ] Run cropped OK
* [ ] Tap focus chat
* [ ] Typing + Enter funciona
* [ ] Drag-scroll usable
* [ ] InputEnabled OFF bloquea control
* [ ] Restart presetup + cambio monitor

---
# recomendación para arrancar sin fricción

1. **Empieza por lo 100% testeable**

   * `calib`
   * `mapper`
   * `gestures` + `actions`
   * `session`
   * unit tests
     Esto te deja la lógica crítica blindada desde el día 1.

2. **Luego el pipeline “visible”**

   * `monitor` (enum)
   * `ffmpeg` presetup/run
   * `webrtc` RTP ingest

3. **Al final UX**

   * UI fullscreen calibrator
   * WS control + signaling
   * typing / drag polish
